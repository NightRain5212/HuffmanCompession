
## 项目说明

- 简要描述主要的模块，主要的步骤，使用的开发语言

### 项目主题

- **基于Huffman编码的文档压缩**
- 主要模块：
	- 使用静态哈夫曼树对文件进行压缩与解压
	- 使用自适应哈夫曼树对文件进行压缩与解压
	- 使用凯撒密码对文件进行加密和解密
- 使用的开发语言：
	- `C++`

## 开始使用

1. 动态huffman压缩文件：`huffman ah-z <outputFile> <inputFile1> <inputFile2> ...`;  
2. 动态huffman解压文件：`huffman ah-d <inputFile>`; 
3. 静态huffman压缩文件：`huffman h-z <outputFile> <inputFile1> <inputFile2> ...`
4. 静态huffman解压文件：`huffman h-d <inputFile>`
5. 凯撒加密文件：`huffman -en <inputFile> <key>`
6. 凯撒解密文件：`huffman -de <inputFile> <key>`
7. 帮助：`huffman -help`

## 压缩率对比分析

| 文件                   | Huffman                              | Adaptive Huffman                     | LZMA                                | bzip2                               |
| -------------------- | ------------------------------------ | ------------------------------------ | ----------------------------------- | ----------------------------------- |
| `doupocangqiong.txt` | 16166490 B-><br>11837103 B<br>73.22% | 16166490 B-><br>11837440 B<br>73.22% | 16166490 B-><br>4007859 B<br>24.79% | 16166490 B-><br>4159477 B<br>25.73% |
| `1.txt 2.txt 3.txt`  | 62061 B<br>37706 B<br>60.76%         | 62061 B-><br>37813 B<br>60.93%       | 62061 B-><br>24174 B<br>38.95%      | 62061 B-><br>21613 B<br>34.83%      |


## 技术细节

- 此部分详细介绍关键步骤的的技术细节，包括程序结构、代码目录截图、每个模块的实现方法等，此部分可贴关键程序的伪代码

### Huffman树构建、编码生成

#### 构建过程

- 先将压缩文件全部扫描一遍，遍历出现过的所有字符，记录所有字符对应的出现次数作为权重
- 根据所有字符的权重大小，每次取出最小的两个字符构建对应的叶子节点，构建其共同的父节点作为中间节点，权重大小为左右孩子权重大小之和，放入待构建字符中。
- 直至所有待构建字符处理完毕，哈夫曼树构建完毕。

#### 编码过程 

- 根据已有的哈夫曼树可确定根到对应字符的唯一路径，规定从一个节点到其左孩子路径为0，到其右孩子路径为1，则根到叶子的路径可用01序列表示，该01序列即字符压缩后的编码。
- 逐个读取字符，获取对应编码输出到压缩文件即可。

#### 解码过程

- 初始化一个指针指向根节点，开始读取压缩后的文件内容
- 如果当前指针指向叶子节点
	- 直接将对应的字符输出到解压文件，再从该节点向上更新。
	- 将字符输出后，重置指针指向根节点。
- 如果指向中间节点，则根据接下来读取的1位二进制数判断是访问左孩子还是右孩子，若是0则访问左孩子，反之访问右孩子。


### 动态Huffman树构建，编码生成

#### 关键概念

- 外部节点
	- 在动态哈夫曼树中用一个统一的外部节点`NYT`来表示尚未出现过的字符，其权重始终为0.
- 兄弟性质
	- 如果哈夫曼树的每一个节点可以按照加权值从小排列到大，且每个节点又再自己的兄弟相邻，称为兄弟性质。
- 节点编号
	- 理想编号：按照哈夫曼树的层次，从上往下，从右往左依次减小编号。
	- 始终保证中间节点的编号比叶子节点的编号小。
	- 节点编号越大的节点离根越近。
- 权重块
	- 所有权重相同的节点按照编号有序排列得到的集合称为权重块。
	- 权重块的”领导者“，即当前权重块中编号最大的那个节点
- 更新操作
	- 动态哈夫曼树在更新的过程中实际上就是要保证兄弟性质的不变性，如果权重的增加破坏了这个不变性，则需要对树的结构和性质进行修改维护。

#### 构建流程

- 初始化：
	- 即一个`NYT`节点作为根节点
- 读取字符时：
	- 如果字符是新字符
		- 则分裂`NYT`节点，形成一个新的`NYT`节点作为原`NYT`节点的左孩子，一个新的代表该字符的叶子节点作为原`NYT`节点的右孩子，原本的`NYT`节点变为中间节点。
		- 再从该右孩子开始往上更新。
	- 如果字符已经出现过
		- 直接从该字符对应的节点开始往上更新。

#### 编码流程

- 使用仅有唯一的`NYT`节点的编码树作为初始状态
- 开始逐个读取字符：
	- 如果字符是新字符
		- 先输出`NYT`在`Huffman`树中的对应编码，表示遇到新字符，再输出该字符的原始编码，表示遇到的新字符是什么。
		- 按上述构建过程构建`Huffman`树
	- 如果字符已经出现过
		- 直接输出字符在`Huffman`树中的对应编码。
		- 按上述构建过程构建`Huffman`树

#### 解码流程

- 解码算法也使用仅有唯一的`NYT`节点的编码树作为初始状态，然后根据`Huffman`编码数据流，对符号进行还原。每次处理完一个符号，就使用这个符号调整编码树。
- 这样，在每一次输入新的符号之前，`Huffman`树都处于与进行编码时使用的`Huffman`树完全相同的状态，保证了解码的正确性。
- 初始化一个指针指向根节点，开始读取压缩后的文件内容
	- 如果当前指针指向叶子节点
		- 如果指向`NYT`节点，则读取接下来8位二进制数，分裂`nyt`，构造对应的`huffman`树，将这原始编码对应的字符输出到解压文件。
		- 如果是字符节点，直接将对应的字符输出到解压文件，再从该节点向上更新。
		- 将字符输出后，重置指针指向根节点。
	- 如果指向中间节点，则根据接下来读取的1位二进制数判断是访问左孩子还是右孩子，若是0则访问左孩子，反之访问右孩子。


### 中文字符与Unicode支持的实现细节

- 由于一个中文字符占3个字节，一个英文字符占1个字节，所以统一对一个字节进行编码和解码，即直接对文件底层的二进制编码中以字节为单位进行编码和解码。


### 凯撒密码加密流程

- 直接对文件逐个字节读取，对每个字节采取`byte = (byte + shift + BYTESIZE) % BYTESIZE`的偏移操作进行加密，再放入加密文件即可。
- 解密则是，对每个字节采取`byte = (byte - shift + BYTESIZE) % BYTESIZE`的偏移。

## 调试分析

### 遇到过的技术困难及解决方式

#### 1.自适应哈夫曼树的构造

- 难点是在更新哈夫曼树的实现，如何正确处理更新哈夫曼树的逻辑是难点
	- 节点编码逻辑：按照理想编码逻辑对节点进行编码难以实现，所以先统计可能最大的符号个数(一个字节256种+nyt节点1种)，确定最大的节点数(`257*2-1`)，每次新建一个节点时，从最大的节点数开始倒序赋给节点编码。
	- 更新逻辑：找到待更新的节点，确定其所处的权重块的领导者，判断能否进行交换，若能，交换后将其权重加一，接下来对将其父节点作为当前节点开始向上更新，直到处理到根节点。


#### 2.处理文件在内存中存储的二进制读写，编码及优化

- 自定义处理输入输出类，内部输入输出流从引用进行构造。
- 由于c++的二进制读写是以字节为单位的，当我们要处理位时必定需要先以字节位中介处理位。
- 由于对逐个字节进行读写会使io效率增大，设置缓冲区对一定数量的字节同时读写，优化io速度。
- 由于构建哈夫曼树时会用到位级别的读写，还需完善对位进行读写的函数。

##### 读取逻辑

- 读取字节时从主读缓冲区逐个获取，若缓冲区的字节全部被读取，则从文件读入接下来一定数量的字节到缓冲区，将缓冲区指针重置，再逐个字节从缓冲区读取。
- 读取位时，从位缓冲区进行逐位读取，待位缓冲区读取完后，从读缓冲区读取新的字节，重置位缓冲区的指针，再进行逐位读取。
- 由于读入时，读入字节与读入位不会混合着用，故可以将读取逻辑简化。

##### 写入逻辑

- 写入字节时，将字节写入写缓冲区，当写缓冲区满时，将写缓冲区里的字节一次性写入文件。
- 写入位时，将位写入位缓冲区，当位缓冲区满一个字节后，将位缓冲区组成的字节写入写缓冲区，重置位缓冲区。


#### 3.压缩文件格式的设计

- 即压缩文件解压时如何正确辨别出源文件
- 压缩文件分区：
	- 文件头部区：一个独特的文件**标识符**，**文件中包含的文件数量** 
	- 文件元数据区：记录每个文件的元数据：**文件名 (File Name)**， **原始文件大小 (Original Size)**
	- (哈夫曼树序列区):如果是静态哈夫曼编码，则需将已经构建的哈夫曼树序列化保存下来，以便解压时重新构建出原本的哈夫曼树进行正确解压。
	- 数据区：`文件1内容 + 文件2内容 + ...` 经过统一压缩后的数据。

##### 压缩流程

- **收集输入**：获取所有要压缩的文件路径列表。
- **打开归档文件**：创建一个新的 `.huff` 文件用于写入。
- **占位**：在文件开头，根据文件数量，先写入一块“占位符”区域。这块区域将来用于存放归档头部和所有文件的元数据。我们需要预先计算它的大小 (`sizeof(SYMBOL) + sizeof(NumFiles) + NumFiles * sizeof(FileMetadata)`)。
- **逐个压缩**：将该文件的压缩数据**直接写入**到占位符区域**之后**的位置，在压缩过程中，记录下它的**原始大小**和**压缩后的大小**，并保存在内存中的一个元数据列表里。
- **回填元数据**：所有文件都压缩完毕后，我们已经收集了所有元数据。将文件写入指针**移回到文件开头**。现在，将最终的归档头部和内存中完整的元数据列表**写入**到之前预留的占位符区域。

##### 解压流程

- **打开归档文件**：打开 `.huff` 文件用于读取。
- **读取头部**：读取“HUFF”标识符进行验证，然后读取文件数量。
- **读取元数据**：根据文件数量，一次性读取整个文件元数据区，存入内存中的`std::vector<FileMetadata>`。
- **逐个解压**：此时，文件读取指针正好位于第一个文件的数据块开头。遍历元数据列表中的每一条记录。根据记录中的`文件名`创建新的输出文件。调用解压逻辑，告诉它需要从归档文件中解压，并且当解压出的字节数达到`原始大小`时停止。因为我们知道每个文件的`压缩后大小`，所以可以确保解压每个文件时不会错误地多读数据。


## 参考文献

- [Visualizing Adaptive Huffman Coding](https://ben-tanen.com/adaptive-huffman/)
- [自适应（动态）哈夫曼编码与解码过程_自适应霍夫曼编码-CSDN博客](https://blog.csdn.net/weixin_43838265/article/details/117324663)
